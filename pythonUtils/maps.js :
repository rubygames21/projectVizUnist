maps.js : 

import * as d3 from 'd3';
import { loadSalesData } from '../utils/dataLoaders/salesDataLoader';
import { loadChargingStations } from '../utils/dataLoaders/chargingStationsLoader';
import { updateLineChartData } from './LineGraph';

const stateNameMap = {
    "AL": "Alabama", "AK": "Alaska", "AZ": "Arizona", "AR": "Arkansas", "CA": "California",
    "CO": "Colorado", "CT": "Connecticut", "DE": "Delaware", "FL": "Florida", "GA": "Georgia",
    "HI": "Hawaii", "ID": "Idaho", "IL": "Illinois", "IN": "Indiana", "IA": "Iowa",
    "KS": "Kansas", "KY": "Kentucky", "LA": "Louisiana", "ME": "Maine", "MD": "Maryland",
    "MA": "Massachusetts", "MI": "Michigan", "MN": "Minnesota", "MS": "Mississippi", "MO": "Missouri",
    "MT": "Montana", "NE": "Nebraska", "NV": "Nevada", "NH": "New Hampshire", "NJ": "New Jersey",
    "NM": "New Mexico", "NY": "New York", "NC": "North Carolina", "ND": "North Dakota", "OH": "Ohio",
    "OK": "Oklahoma", "OR": "Oregon", "PA": "Pennsylvania", "RI": "Rhode Island", "SC": "South Carolina",
    "SD": "South Dakota", "TN": "Tennessee", "TX": "Texas", "UT": "Utah", "VT": "Vermont",
    "VA": "Virginia", "WA": "Washington", "WV": "West Virginia", "WI": "Wisconsin", "WY": "Wyoming",
    "DC": "District of Columbia"
};
const salesCache = {}; // Cache global pour les ventes
let selectedStartDate = new Date(2016, 0, 1);
let selectedEndDate = new Date(2023, 0, 1);
let activeState = null;
let stationCountsByState = {}; 

export function updateTimelineDates(startDate, endDate) {
    selectedStartDate = startDate;
    selectedEndDate = new Date(endDate.getFullYear(), endDate.getMonth() + 1, 0); // Dernier jour du mois
    updateFilteredData();
}

function updateSelectedState(state, stations, svg, projection) {
    svg.selectAll('path').classed('selected-state', false);

    if (activeState === state) {
        activeState = null;
        hideStations(svg.select('.station-layer'));
    } else {
        activeState = state;
        displayStationsForState(svg.select('.station-layer'), stations, state, projection);

        svg.selectAll('path')
            .filter(d => d.properties.NAME === state)
            .classed('selected-state', true);
    }
    updateFilteredData();
}

function updateFilteredData() {
    loadChargingStations().then(stations => {
        const filteredStations = stations.filter(station => {
            const isInDateRange = station.properties.openDate >= selectedStartDate && station.properties.openDate <= selectedEndDate;
            return isInDateRange;
        });

        // Calculer le nombre de stations par état pour la période sélectionnée
        stationCountsByState = filteredStations.reduce((counts, station) => {
            const stateAbbr = station.properties.state;
            const stateName = stateNameMap[stateAbbr] || stateAbbr;
            counts[stateName] = (counts[stateName] || 0) + 1;
            return counts;
        }, {});

        // Mettre à jour le graphique de ligne avec les données filtrées
        updateLineChartData(filteredStations);

        // Mettre à jour les attributs de chaque état dans la carte
        d3.selectAll('.state').each(function(d) {
            const state = d.properties.NAME;
            d3.select(this).attr('data-station-count', stationCountsByState[state] || 0);
        });
    });
}

function calculateSalesForPeriod(salesData, state, startDate, endDate) {
    console.log(`Appel pour ${state} : startDate = ${startDate}, endDate = ${endDate}`);

    let totalSales = 0;

    // Obtenez l'année et le mois de début/fin
    const startYear = startDate.getFullYear();
    const endYear = endDate.getFullYear();
    const startMonth = startDate.getMonth(); // Mois de début (0-indexé, janvier = 0)
    const endMonth = endDate.getMonth(); // Mois de fin (0-indexé, janvier = 0)

    // Vérifiez si les ventes pour l'état existent
    const stateSales = salesData[state];
    if (!stateSales) {
        console.error(`Aucune donnée trouvée pour l'état ${state}`);
        return 0;
    }

    // Parcourez les années dans la période sélectionnée
    for (let year = startYear; year <= endYear; year++) {
        const salesForYear = stateSales[year]; // Ventes de l'année actuelle
        if (!salesForYear) continue; // Passez si aucune donnée pour l'année

        let monthsInRange = 0;

        if (year === startYear && year === endYear) {
            // Période dans une seule année
            monthsInRange = endMonth - startMonth + 1; // Mois inclusifs
            totalSales += (salesForYear / 12) * monthsInRange;
        } else if (year === startYear) {
            // Année de début partielle
            monthsInRange = 12 - startMonth; // Mois restants à partir de startMonth
            totalSales += (salesForYear / 12) * monthsInRange;
        } else if (year === endYear) {
            // Année de fin partielle
            monthsInRange = endMonth + 1; // Mois jusqu'à endMonth
            totalSales += (salesForYear / 12) * monthsInRange;
        } else {
            // Année entière incluse
            monthsInRange = 12;
            totalSales += salesForYear;
        }

        // Ajoutez un console.log pour vérifier les calculs
        console.log(`Année : ${year}, Mois sélectionnés : ${monthsInRange}, Ventes annuelles : ${salesForYear}, Ventes calculées pour cette année : ${(salesForYear / 12) * monthsInRange}`);
    }

    return Math.round(totalSales); // Arrondissez le total
}


function updateTooltipContent(state, salesData) {
    const cacheKey = `${state}-${selectedStartDate.toISOString()}-${selectedEndDate.toISOString()}`;
    if (!salesCache[cacheKey]) {
        salesCache[cacheKey] = {
            EV: calculateSalesForPeriod(salesData.EV, state, selectedStartDate, selectedEndDate),
            HEV: calculateSalesForPeriod(salesData.HEV, state, selectedStartDate, selectedEndDate),
            PHEV: calculateSalesForPeriod(salesData.PHEV, state, selectedStartDate, selectedEndDate)
        };
    }

    const { EV, HEV, PHEV } = salesCache[cacheKey];
    const stationCount = stationCountsByState[state] || 0;

    return `
        <strong>${state}</strong><br>
        EV Sales: ${EV}<br>
        HEV Sales: ${HEV}<br>
        PHEV Sales: ${PHEV}<br>
        Charging Stations: ${stationCount}
    `;
}


function initializeStationCountsByState() {
    return loadChargingStations().then(stations => {
        const filteredStations = stations.filter(station => {
            const isInDateRange = station.properties.openDate >= selectedStartDate && station.properties.openDate <= selectedEndDate;
            return isInDateRange;
        });

        return filteredStations.reduce((counts, station) => {
            const stateAbbr = station.properties.state;
            const stateName = stateNameMap[stateAbbr] || stateAbbr;
            counts[stateName] = (counts[stateName] || 0) + 1;
            return counts;
        }, {});
    });
}

export function renderMap() {
    const container = d3.select('.map');
    const width = container.node().getBoundingClientRect().width;
    const height = container.node().getBoundingClientRect().height;

    const projection = d3.geoAlbersUsa()
        .translate([width / 2, height / 2])
        .scale(Math.min(width, height) * 2.2);

    const path = d3.geoPath().projection(projection);

    const svg = container.append('svg')
        .attr('width', width)
        .attr('height', height);

    const tooltip = d3.select('body')
        .append('div')
        .attr('class', 'tooltip');

    Promise.all([loadSalesData(), initializeStationCountsByState(), loadChargingStations()])
        .then(([salesData, initialStationCountsByState, stations]) => {
            stationCountsByState = initialStationCountsByState;

            d3.json('/data/us-states.json').then(geoData => {
                drawMap(svg, geoData, path, tooltip, salesData, stations, projection);
                const stationLayer = svg.append('g').attr('class', 'station-layer');
                setupZoom(svg, path, projection, geoData, tooltip, salesData, stations, stationLayer);
            });
        });
}

function drawMap(svg, data, path, tooltip, salesData, stations, projection) {
    svg.selectAll('path')
        .data(data.features)
        .enter()
        .append('path')
        .attr('d', path)
        .attr('fill', '#4a90e2')
        .attr('stroke', '#ffffff')
        .attr('stroke-width', 1)
        .attr('class', 'state')
        .on('mouseover', function(event, d) {
            d3.select(this).attr('fill', '#ffcc00');
            const state = d.properties.NAME;
            const content = updateTooltipContent(state, salesData); // Utilise le cache ici
            tooltip.style('opacity', 1).html(content);
        })
        .on('mousemove', function(event) {
            const [x, y] = d3.pointer(event);
            tooltip
                .style('left', `${x + 15}px`)
                .style('top', `${y + 15}px`);
        })
        .on('mouseout', function() {
            d3.select(this).attr('fill', '#4a90e2');
            tooltip.style('opacity', 0);
        });
}

function displayStationsForState(layer, stations, state, projection, scale = 1) {
    hideStations(layer);

    if (!Array.isArray(stations)) return;

    const filteredStations = stations.filter(station => {
        const isInState = station.properties.state === state;
        const isInDateRange = station.properties.openDate >= selectedStartDate && station.properties.openDate <= selectedEndDate;
        const hasValidCoordinates = station.geometry.coordinates[0] && station.geometry.coordinates[1];
        return isInState && isInDateRange && hasValidCoordinates;
    });

    layer.selectAll('circle')
        .data(filteredStations)
        .enter()
        .append('circle')
        .attr('cx', d => projection(d.geometry.coordinates)[0])
        .attr('cy', d => projection(d.geometry.coordinates)[1])
        .attr('r', 4 / scale)
        .attr('fill', 'red')
        .attr('stroke', '#000')
        .attr('stroke-width', 1);
}

function hideStations(layer) {
    layer.selectAll('circle').remove();
}

function limitTranslate(transform, width, height) {
    const scale = transform.k;
    const xLimit = (width * scale - width) / 2;
    const yLimit = (height * scale - height) / 2;
    transform.x = Math.max(Math.min(transform.x, xLimit), width - width * scale);
    transform.y = Math.max(Math.min(transform.y, yLimit), height - height * scale);
    return transform;
}

function setupZoom(svg, path, projection, geoData, tooltip, salesData, stations, stationLayer) {
    const width = svg.attr('width');
    const height = svg.attr('height');

    const zoom = d3.zoom()
        .scaleExtent([1, 8])
        .on('zoom', (event) => {
            const transform = limitTranslate(event.transform, width, height);

            svg.selectAll('path').attr('transform', transform);
            stationLayer.attr('transform', transform);

            stationLayer.selectAll('circle')
                .attr('r', 4 / transform.k)
                .attr('stroke-width', 1 / transform.k);
        });

    svg.call(zoom);
}
