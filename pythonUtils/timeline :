timeline : 

import * as d3 from 'd3';

let onDateRangeChange = null;

export function renderTimeline(callback) {
    onDateRangeChange = callback; // Stocker la fonction de rappel
    const container = d3.select('.timeline');
    const width = container.node().getBoundingClientRect().width;
    const height = container.node().getBoundingClientRect().height;

    const startDate = new Date(2016, 0, 1); // Début : 1er janvier 2016
    const endDate = new Date(2023, 0, 1);  // Fin : 1er janvier 2023

    const padding = 10;
    const xScale = d3.scaleTime()
        .domain([startDate, endDate])
        .range([0 + padding, width - (22 + padding)]);

    const svg = d3.select('.timeline')
        .append('svg')
        .attr('width', width)
        .attr('height', height);

    const monthTicks = svg.append('g')
        .attr('class', 'month-ticks')
        .attr('transform', `translate(0, ${height - 25})`);

    const months = d3.timeMonths(startDate, endDate);
    monthTicks.selectAll('line')
        .data(months)
        .enter()
        .append('line')
        .attr('x1', d => xScale(d))
        .attr('y1', 0)
        .attr('x2', d => xScale(d))
        .attr('y2', 5) // Longueur des petits traits
        .attr('stroke', 'black')
        .attr('stroke-width', 1);

    // Ajoutez l'axe des années sans sous-ticks
    const xAxis = d3.axisBottom(xScale)
        .ticks(d3.timeYear)
        .tickSize(0);

    svg.append('g')
        .attr('transform', `translate(0, ${height - 20})`)
        .call(xAxis);

    let selectedStart = startDate;
    let selectedEnd = new Date(startDate.getFullYear(), startDate.getMonth() + 1, 0); // Dernier jour du mois

    const selection = svg.append('rect')
        .attr('class', 'selection')
        .attr('x', xScale(selectedStart))
        .attr('y', 10)
        .attr('width', xScale(selectedEnd) - xScale(selectedStart))
        .attr('height', height - 30)
        .attr('fill', 'rgba(70, 130, 180, 0.3)');

    const handleWidth = 10;

    const startHandle = svg.append('rect')
        .attr('class', 'handle')
        .attr('x', xScale(selectedStart) - handleWidth / 2)
        .attr('y', 5)
        .attr('width', handleWidth)
        .attr('height', height - 20)
        .attr('fill', 'steelblue')
        .call(d3.drag()
            .on('drag', (event) => {
                const newStart = snapToMonth(xScale.invert(event.x));
                if (newStart < selectedEnd && newStart >= startDate) {
                    selectedStart = newStart;
                    updateSelection();
                }
            })
        );

    const endHandle = svg.append('rect')
        .attr('class', 'handle')
        .attr('x', xScale(selectedEnd) - handleWidth / 2)
        .attr('y', 5)
        .attr('width', handleWidth)
        .attr('height', height - 20)
        .attr('fill', 'steelblue')
        .call(d3.drag()
            .on('drag', (event) => {
                const newEnd = snapToMonth(xScale.invert(event.x));
                if (newEnd > selectedStart && newEnd <= endDate) {
                    selectedEnd = newEnd;
                    updateSelection();
                }
            })
        );

    function snapToMonth(date) {
        return new Date(date.getFullYear(), date.getMonth(), 1);
    }

    function updateSelection() {
        const adjustedEnd = new Date(selectedEnd.getFullYear(), selectedEnd.getMonth() + 1, 0);

        // Si la sélection est réduite à un seul mois, ajustez correctement
        if (xScale(adjustedEnd) - xScale(selectedStart) < handleWidth) {
            selectedEnd = new Date(selectedStart.getFullYear(), selectedStart.getMonth() + 1, 0);
        }

        selection
            .attr('x', xScale(selectedStart))
            .attr('width', xScale(adjustedEnd) - xScale(selectedStart));

        startHandle.attr('x', xScale(selectedStart) - handleWidth / 2);
        endHandle.attr('x', xScale(adjustedEnd) - handleWidth / 2);

        console.log(`Plage sélectionnée ajustée : ${selectedStart.toDateString()} - ${adjustedEnd.toDateString()}`);

        if (onDateRangeChange) {
            onDateRangeChange(selectedStart, adjustedEnd);
        }
    }

    // Initialiser la sélection
    updateSelection();
}
